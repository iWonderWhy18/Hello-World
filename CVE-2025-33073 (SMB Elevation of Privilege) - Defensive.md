
During Microsoft's June 2025 Patch Tuesday review, an elevation of privilege vulnerability was listed. If exploited successfully, attackers could achieve elevation of privilege on the compromised machine. In this lab, you'll learn about this vulnerability and how to detect indicators of compromise in Splunk logs.

**CVE ID:** CVE-2025-33073

**Base score:** 8.8

**CVSS:3.1** [/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H](https://nvd.nist.gov/vuln/detail/CVE-2025-33073)

**Description:** Improper access control in Windows SMB allows an authorized attacker to elevate privileges over a network.

**Vulnerable versions:** Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation), Windows Server 2008 R2 for x64-based Systems Service Pack 1, Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation), Windows Server 2008 for x64-based Systems Service Pack 2, Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation), Windows Server 2008 for 32-bit Systems Service Pack 2, Windows Server 2016 (Server Core installation), Windows Server 2016, Windows 10 Version 1607 for x64-based Systems, Windows 10 Version 1607 for 32-bit Systems, Windows Server 2012 R2 (Server Core installation), Windows Server 2012 R2, Windows Server 2012 (Server Core installation), Windows Server 2012, Windows 10 for x64-based Systems, Windows 10 for 32-bit Systems, Windows Server 2025, Windows 11 Version 24H2 for x64-based Systems, Windows 11 Version 24H2 for ARM64-based Systems, Windows Server 2022, 23H2 Edition (Server Core installation), Windows 11 Version 23H2 for x64-based Systems, Windows 11 Version 23H2 for ARM64-based Systems, Windows Server 2025 (Server Core installation), Windows 10 Version 22H2 for 32-bit Systems, Windows 10 Version 22H2 for ARM64-based Systems, Windows 10 Version 22H2 for x64-based Systems, Windows 11 Version 22H2 for x64-based Systems, Windows 11 Version 22H2 for ARM64-based Systems, Windows 10 Version 21H2 for x64-based Systems, Windows 10 Version 21H2 for ARM64-based Systems, Windows 10 Version 21H2 for 32-bit Systems, Windows Server 2022 (Server Core installation), Windows Server 2022, Windows Server 2019 (Server Core installation), Windows Server 2019, Windows 10 Version 1809 for x64-based Systems, Windows 10 Version 1809 for 32-bit Systems.

**NIST details:** [https://nvd.nist.gov/vuln/detail/CVE-2025-33073](https://nvd.nist.gov/vuln/detail/CVE-2025-33073)

**Proof of concept research:** [https://www.synacktiv.com/en/publications/ntlm-reflection-is-dead-long-live-ntlm-reflection-an-in-depth-analysis-of-cve-2025#understanding-the-vulnerability](https://www.synacktiv.com/en/publications/ntlm-reflection-is-dead-long-live-ntlm-reflection-an-in-depth-analysis-of-cve-2025#understanding-the-vulnerability)

**Active exploitation:** False

![[Pasted image 20250814094648.png]]

## The vulnerability

CVE-2025-33073 is a Windows Server Message Block (SMB) client-side privilege escalation (logical) vulnerability. It allows an authenticated remote attacker to execute arbitrary commands as SYSTEM on machines where SMB signing isn't enforced. SMB signing is a security mechanism used in the SMB protocol to ensure the authenticity and integrity of SMB traffic between systems.

Windows supports a special New Technology LAN Manager (NTLM) local authentication path for connections from the same host, optimized via loopback. It uses internal context flags (Negotiate Local Call), letting `lsass.exe` bypass full NTLM challenge‑response.

Researchers at Synacktiv found that coercing the client into connecting to a fabricated DNS name – matching its own hostname – triggers this loopback behavior, even when relaying via Kerberos. The SMB client (`mrxsmb.sys`) passes this target name to `InitializeSecurityContextW`, which LSASS identifies via NegpIsLoopback, leading it to prefer NTLM local authentication over other protocols.

### NTLM local authentication

NTLM local authentication is a special variant of NTLM, in which the server signals to the client, through the `NTLM_CHALLENGE` message, that it doesn’t need to compute a standard challenge-response. Instead, the server sets the "Negotiate Local Call" flag and creates a local server context. This context is stored in a global list, and its identifier is inserted into the “Reserved” field of the challenge message.

When the client receives this message, it recognizes that local NTLM authentication is being requested. It then adds its security token to the server’s context, using the ID provided in the “Reserved” field. Since both client and server are running on the same machine, all of this occurs within the same `lsass.exe` process.

Finally, the client sends back an `NTLM_AUTHENTICATE` message that contains almost no data. The server retrieves the token from its context and uses it to perform further actions (such as authenticating SMB requests in this case).

To determine whether local NTLM authentication should be used, the server examines two fields in the `NTLM_NEGOTIATE` message: the workstation name and the domain name. The function `msv1_0!SsprHandleNegotiateMessage` checks whether these values are provided by the client, and if they are, compares them against the local machine’s name and domain.

[Synacktiv explains](https://www.synacktiv.com/en/publications/ntlm-reflection-is-dead-long-live-ntlm-reflection-an-in-depth-analysis-of-cve-2025#understanding-the-vulnerability) that if both the workstation and domain match the server's own, the server concludes that the client is on the same host. It then sets the `NTLMSSP_NEGOTIATE_LOCAL_CALL` flag in the `NTLM_CHALLENGE` message, creates a corresponding server context, and inserts its context ID into the Reserved field of the message.

Here's a simplified version of the logic used in this process:

```powershell
NTSTATUS SsprHandleNegotiateMessage([...])
{
    Context = LocalAlloc(0x160);
[...]
    if ( RtlEqualString(&ClientSpecifiedWorkstationName, &NtLmGlobalOemPhysicalComputerNameString, 0) && RtlEqualString(&ClientSpecifiedDomainName, &NtLmGlobalOemPrimaryDomainNameString, 0) )
    {
        Context->Id = NtLmGlobalLoopbackCounter + 1;
        ChallengeMessage->Flags |= NTLMSSP_NEGOTIATE_LOCAL_CALL;
        InsertHeadList(&NtLmGlobalLoopbackContextListHead, Context);
        ChallengeMessage->ServerContextHandle = Context->Id;
    }
[...]
}
```

An NTLM relay to the same machine typically fails because Windows recognizes the loopback and enforces protections, especially when the authentication comes from system services like `lsass.exe`.

When an SMB authentication attempt originates from the local machine to its own hostname, `LSASS` sets the "Negotiate Local Call" flag in the `NTLM_CHALLENGE` message. This tells the client that no challenge-response is needed — instead, it should inject its token into the server context via a shared in-memory space, as both client and server are the same process (`lsass.exe`). NTLM relay attacks are normally blocked in same-host scenarios, because of this loopback logic.

However, this behavior can be bypassed using a specially crafted DNS hostname, which resembles a Base64-encoded string where the string is an IP address. For example:

```
srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA
```

This name tricks Windows into treating the destination as itself, even though it's resolving to an external IP controlled by the attacker.

By registering this crafted DNS record (e.g. via `dnstool.py`) and coercing the machine (e.g. via `PetitPotam`) to authenticate to it, the authentication flow mimics a local loopback but reaches the attacker’s relay server.

When `ntlmrelayx.py` receives this authentication, it's able to relay it back to the original host using SMB. Since the host believes it's a legitimate local call, it accepts the token and allows privileged operations to succeed, such as dumping the SAM hive.

So, if the target hostname was wrk1, the Base64 encoded string would need to be:

```
wrk11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA
```



## Exploitation

### Exploitation steps

First, an attacker uses the credentials of a low-privileged user. They add the malicious DNS A record, which points to their attacker-controlled machine.

![[Pasted image 20250814095636.png]]

Next, the attacker starts an SMB relay on the attacker machine that targets the hostname of the workstation.

Finally, the attacker runs a program to coerce machine account authentication with the DC, achieving command execution or simply dumping the hive.

Once the exploitation is successful and the attacker runs a command execution attack against the target (using the command `whoami` in this example), you get the output as below:

![[Pasted image 20250814095713.png]]

In order for a command to run in this way, Windows sets up a temporary .bat file in the temp folder. This can be an indicator of compromise after the Base64 string has been recorded.



## Detection and mitigation

To remediate this vulnerability, there are a number of steps you can take:

- **Patch immediately:** Go to [Microsoft's advisory](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2025-33073) for more information.
- **Enforce SMB signing on your machine:** This prevents vulnerabilities relating to authentication relay in SMB.

For further context, [Synacktiv](https://www.synacktiv.com/en/publications/ntlm-reflection-is-dead-long-live-ntlm-reflection-an-in-depth-analysis-of-cve-2025#understanding-the-vulnerability) reviewed the `mrxsmb.sys` drivers' functions before and after the patch. They found that some functions were changed, specifically `mrxsmb!SmbCeCreateSrvCall`, which is called when trying to access a resource over SMB. The following code was added to `mrxsmb.sys` by Microsoft:

```
NTSTATUS SmbCeCreateSrvCall([...])
{
[...]
    if ((unsigned int)CredUnmarshalTargetInfo(TargetName->Buffer, TargetName->Length, 0, 0) != STATUS_INVALID_PARAMETER ) {
        return STATUS_INVALID_PARAMETER;
    }
[...]
```

Defense-in-depth mitigations such as SMB signing go a long way in preventing these types of vulnerabilities. The rule of thumb is that if a tool, system, or service isn't needed for a specific purpose, it should be removed or tightly locked down.


## In this lab

In this lab, you’ll take on the role of a junior SOC analyst. Unusual activity has been detected linked to this vulnerability. You'll need to go into the Splunk logs and identify indicators of compromise.

